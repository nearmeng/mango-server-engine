/* This file is generated by tdr. */
/* No manual modification is permitted. */

/* tdr version: 2.7.37 */

#ifndef TSF4G_TDR_TDR_ERROR_H_
#define TSF4G_TDR_TDR_ERROR_H_

namespace tsf4g_tdr
{


#include <stdio.h>
#include <string.h>

#define TDR_ERR_SERVICE_MIN_ERRNO 200
#define TDR_BACK_TRACE_MAX_LEN    10240

class TdrError
{
    public:
        enum ErrorType
        {
            TDR_NO_ERROR = 0,
            TDR_ERR_SHORT_BUF_FOR_WRITE             =  -1,
            TDR_ERR_SHORT_BUF_FOR_READ              =  -2,
            TDR_ERR_STR_LEN_TOO_BIG                 =  -3,
            TDR_ERR_STR_LEN_TOO_SMALL               =  -4,
            TDR_ERR_STR_LEN_CONFLICT                =  -5,
            TDR_ERR_MINUS_REFER_VALUE               =  -6,
            TDR_ERR_REFER_SURPASS_COUNT             =  -7,
            TDR_ERR_ARG_POINTER_IS_NULL             =  -8,
            TDR_ERR_CUTVER_TOO_SMALL                =  -9,
            TDR_ERR_CUTVER_CONFILICT                = -10,
            TDR_ERR_PARSE_TDRIP_FAILED              = -11,
            TDR_ERR_INVALID_TDRIP_VALUE             = -12,
            TDR_ERR_INVALID_TDRTIME_VALUE           = -13,
            TDR_ERR_INVALID_TDRDATE_VALUE           = -14,
            TDR_ERR_INVALID_TDRDATETIME_VALUE       = -15,
            TDR_ERR_FUNC_LOCALTIME_FAILED           = -16,
            TDR_ERR_INVALID_HEX_STR_LEN             = -17,
            TDR_ERR_INVALID_HEX_STR_FORMAT          = -18,
            TDR_ERR_NULL_POINTER_PARAMETER          = -19,
            TDR_ERR_NET_CUTVER_INVALID              = -20,
            TDR_ERR_VALUE_UNDER_OR_OVER_FLOW        = -21,
            TDR_ERR_OPEN_FILE_READ_FAILED           = -22,
            TDR_ERR_OPEN_FILE_WRITE_FAILED          = -23,
            TDR_ERR_READ_FILE_FAILED                = -24,
            TDR_ERR_WRITE_FILE_FAILED               = -25,
            TDR_ERR_ALLOC_MEMORY_FAILED             = -26,
            TDR_ERR_PARSE_XML_FAILED                = -27,
            TDR_ERR_INVALID_ROOT_NODE               = -28,
            TDR_ERR_FAILED_TO_PARSE_NUMERIC         = -29,
            TDR_ERR_UNDEFINED_MACRO_NAME            = -30,
            TDR_ERR_FUNCTION_NOT_IMPLEMENTED        = -31,
            TDR_ERR_BAD_TLV_MAGIC                   = -32,
            TDR_ERR_SUSPICIOUS_SELECTOR             = -33,
            TDR_ERR_UNMATCHED_LENGTH                = -34,
            TDR_ERR_UNKNOWN_TYPE_ID                 = -35,
            TDR_ERR_LOST_REQUIRED_FIELD             = -36,
            TDR_ERR_NULL_ARRAY                      = -37,
            TDR_ERR_FIELD_NAME_IS_NOT_EXIST    = -38,
            TDR_ERR_NOT_SUPPORT                = -39,
            TDR_ERR_UNKNOWN_FIELD_ID           = -40,
            TDR_ERR_UNMATCH_TAG_ID             = -41,
            TDR_ERR_UNMATCH_TYPE_ID            = -42,
            TDR_ERR_NOT_FIND                   = -43,

            /* tdr error for service */
            TDR_ERR_SERVICE_NULL_RPC_CLIENT         = -(TDR_ERR_SERVICE_MIN_ERRNO),
            TDR_ERR_SERVICE_METHOD_NOT_IMPLEMENTED  = -(TDR_ERR_SERVICE_MIN_ERRNO + 1),
            TDR_ERR_SERVICE_NULL_CLOSURE            = -(TDR_ERR_SERVICE_MIN_ERRNO + 2),
            TDR_ERR_SERVICE_UNKNOWN_METHOD          = -(TDR_ERR_SERVICE_MIN_ERRNO + 3),
        };

    public:
        static const char* getErrorString(ErrorType errorCode);
        static void addBackTrace(const char* child_name, const char* file_name, int line_num);

    public:
        static int start_pos;
        static char back_trace_str[TDR_BACK_TRACE_MAX_LEN];

};

#define RESET_START_POS() { TdrError::start_pos = TDR_BACK_TRACE_MAX_LEN - 1; }

// Inner used macro, mainly called by function addBackTrace.
#define ADD_BACK_TRACE_2_GLOBAL_BUFF(new_back_trace) \
{ \
int str_len = 0; \
if (TdrError::start_pos >= (int)strlen(new_back_trace)) \
{ \
    str_len = strlen(new_back_trace); \
    TdrError::start_pos = TdrError::start_pos - str_len; \
} \
else if (TdrError::start_pos > 0) \
{ \
    str_len = TdrError::start_pos; \
    TdrError::start_pos = 0; \
} \
strncpy(TdrError::back_trace_str+TdrError::start_pos, new_back_trace, str_len); \
}

#if defined(_WIN32) || defined(_WIN64)
#define TDR_GET_BACKTRACE(pkg, retcode) tsf4g_tdr::TdrError::getErrorString((TdrError::ErrorType)retcode);
#define tdr_get_backtrace(pkg, retcode) tsf4g_tdr::TdrError::getErrorString((TdrError::ErrorType)retcode);

#else
// Only used when command: tdr -P CAUTION: multi-thread UNSAFE
#define TDR_GET_BACKTRACE(pkg, retcode) \
({ \
using namespace tsf4g_tdr; \
char class_back_strace[256] = {0}; \
snprintf(class_back_strace, sizeof(class_back_strace), ", Back_Trace: struct_name[%s]", (pkg).m_class_name); \
ADD_BACK_TRACE_2_GLOBAL_BUFF(class_back_strace); \
\
ADD_BACK_TRACE_2_GLOBAL_BUFF(TdrError::getErrorString((TdrError::ErrorType)retcode)); \
ADD_BACK_TRACE_2_GLOBAL_BUFF("Failed_Reason: "); \
\
int move_len = TDR_BACK_TRACE_MAX_LEN - TdrError::start_pos; \
memmove(TdrError::back_trace_str, TdrError::back_trace_str + TdrError::start_pos, move_len); \
TdrError::back_trace_str[TDR_BACK_TRACE_MAX_LEN-1] = '\0'; \
TdrError::back_trace_str; \
})

#define tdr_get_backtrace(pkg, retcode) TDR_GET_BACKTRACE((pkg), (retcode))
#endif


}
#endif
